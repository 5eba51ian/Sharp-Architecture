//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace SharpArch.Specifications.NHibernate
{
    using System;

    using global::SharpArch.Domain;
    using global::SharpArch.Domain.DomainModel;
    using global::SharpArch.Domain.PersistenceSupport;
    using global::SharpArch.Features.Specifications;
    using global::SharpArch.NHibernate.NHibernateValidator;

    using Machine.Specifications;
    using Machine.Specifications.AutoMocking.Rhino;

    using Rhino.Mocks;

    public class has_unique_domain_signature_specs
    {
        public abstract class specification_for_has_unique_domain_signature_validator : Specification<HasUniqueDomainSignatureValidator>
        {
            protected static IEntityDuplicateChecker entityDuplicateChecker;

            Establish context = () =>
            {
                ServiceLocatorHelper.AddValidator();

                entityDuplicateChecker = An<IEntityDuplicateChecker>();
                entityDuplicateChecker.AddToServiceLocator();
            };

            Cleanup after = ServiceLocatorHelper.Reset;
        }

        [Subject(typeof(HasUniqueDomainSignatureValidator))]
        public class when_validating_an_entity_and_a_duplicate_exists : specification_for_has_unique_domain_signature_validator
        {
            static Contractor contractor;
            static bool result;

            Establish context = () =>
            {
                contractor = new Contractor() { Name = "codai" };
                entityDuplicateChecker.Stub(x => x.DoesDuplicateExistWithTypedIdOf(contractor)).Return(true);
            };

            Because of = () =>
            {
                result = contractor.IsValid();
            };

            It should_ask_the_entity_duplicate_checker_if_a_duplicate_entity_exists = () =>
                entityDuplicateChecker.AssertWasCalled(x => x.DoesDuplicateExistWithTypedIdOf(contractor));

            It should_say_the_entity_is_invalid = () => result.ShouldBeFalse();
        }

        [Subject(typeof(HasUniqueDomainSignatureWithGuidIdValidator))]
        public class when_validating_an_entity_with_a_guid_id_and_a_duplicate_exists : specification_for_has_unique_domain_signature_validator
        {
            static ObjectWithGuidId objectWithGuidId1;
            static bool result;

            Establish context = () =>
            {
                objectWithGuidId1 = new ObjectWithGuidId { Name = "codai" };
                entityDuplicateChecker.Stub(x => x.DoesDuplicateExistWithTypedIdOf(objectWithGuidId1)).Return(true);
            };

            Because of = () => result = objectWithGuidId1.IsValid();

            It should_ask_the_entity_duplicate_checker_if_a_duplicate_entity_exists = () =>
                entityDuplicateChecker.AssertWasCalled(x => x.DoesDuplicateExistWithTypedIdOf(objectWithGuidId1));

            It should_say_the_entity_is_invalid = () => result.ShouldBeFalse();
        }

        [Subject(typeof(HasUniqueDomainSignatureWithStringIdValidator))]
        public class when_validating_an_entity_with_a_string_id_and_a_duplicate_exists : specification_for_has_unique_domain_signature_validator
        {
            static User user;
            static bool result;

            Establish context = () =>
            {
                user = new User { SSN = "123-12-1234" };
                entityDuplicateChecker.Stub(x => x.DoesDuplicateExistWithTypedIdOf(user)).Return(true);
            };

            Because of = () => result = user.IsValid();

            It should_ask_the_entity_duplicate_checker_if_a_duplicate_entity_exists = () =>
                entityDuplicateChecker.AssertWasCalled(x => x.DoesDuplicateExistWithTypedIdOf(user));

            It should_say_the_entity_is_invalid = () => result.ShouldBeFalse();
        }

        [Subject(typeof(HasUniqueDomainSignatureValidator))]
        public class when_validating_an_entity_and_the_entity_is_unique : specification_for_has_unique_domain_signature_validator
        {
            static Contractor contractor;
            static bool result;

            Establish context = () =>
            {
                contractor = new Contractor { Name = "the name" };
                entityDuplicateChecker.Stub(x => x.DoesDuplicateExistWithTypedIdOf(contractor)).Return(false);
            };

            Because of = () => result = contractor.IsValid();

            It should_ask_the_entity_duplicate_checker_if_a_duplicate_entity_exists = () =>
                entityDuplicateChecker.AssertWasCalled(x => x.DoesDuplicateExistWithTypedIdOf(contractor));

            It should_say_the_entity_is_valid = () => result.ShouldBeTrue();
        }

        [Subject(typeof(HasUniqueDomainSignatureValidator))]
        public class when_validating_an_entity_with_the_wrong_validator_type : specification_for_has_unique_domain_signature_validator
        {
            static ObjectWithStringIdAndValidatorForIntId entity;
            static Exception result;

            Establish context = () =>
            {
                Check.UseAssertions = false;
                entity = new ObjectWithStringIdAndValidatorForIntId { Name = "whatever" };
            };

            Because of = () => result = Catch.Exception(() => entity.IsValid());

            It should_throw_a_precondition_exception = () => result.ShouldBeOfType(typeof(PreconditionException));
        }

        #region Private Methods

        [HasUniqueDomainSignature]
        class Contractor : Entity
        {
            #region Properties

            [DomainSignature]
            public string Name { get; set; }

            #endregion
        }

        [HasUniqueDomainSignatureWithGuidId]
        class ObjectWithGuidId : EntityWithTypedId<Guid>
        {
            #region Properties

            [DomainSignature]
            public string Name { get; set; }

            #endregion
        }

        [HasUniqueDomainSignature]
        class ObjectWithStringIdAndValidatorForIntId : EntityWithTypedId<string>
        {
            #region Properties

            [DomainSignature]
            public string Name { get; set; }

            #endregion
        }

        [HasUniqueDomainSignatureWithStringId]
        class User : EntityWithTypedId<string>
        {
            #region Properties

            [DomainSignature]
            public string SSN { get; set; }

            #endregion
        }

        #endregion
    }
}